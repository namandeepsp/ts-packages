
===== ./package.json =====
{
    "name": "@naman_deep_singh/errors",
    "version": "2.3.0",
    "description": "Standardized error classes and Express middleware for consistent error handling with TypeScript",
    "type": "module",
    "main": "./dist/cjs/index.js",
    "module": "./dist/esm/index.js",
    "types": "./dist/types/index.d.ts",
    "exports": {
        ".": {
            "import": "./dist/esm/index.js",
            "require": "./dist/cjs/index.js",
            "types": "./dist/types/index.d.ts"
        },
        "./error": {
            "import": "./dist/esm/error/index.js",
            "require": "./dist/cjs/error/index.js",
            "types": "./dist/types/error/index.d.ts"
        },
        "./errorRegistry": {
            "import": "./dist/esm/errorRegistry/index.js",
            "require": "./dist/cjs/errorRegistry/index.js",
            "types": "./dist/types/errorRegistry/index.d.ts"
        },
        "./constants": {
            "import": "./dist/esm/constants/index.js",
            "require": "./dist/cjs/constants/index.js",
            "types": "./dist/types/constants/index.d.ts"
        },
        "./middleware/express": {
            "import": "./dist/esm/middleware/express/index.js",
            "require": "./dist/cjs/middleware/express/index.js",
            "types": "./dist/types/middleware/express/index.d.ts"
        }
    },
    "sideEffects": false,
    "files": [
        "dist",
        "README.md"
    ],
    "scripts": {
        "build": "pnpm run build:types && tsc -p tsconfig.cjs.json && tsc -p tsconfig.esm.json",
        "build:types": "tsc -p tsconfig.types.json",
        "clean": "rimraf dist",
        "prepublishOnly": "npm run clean && npm run build"
    },
    "keywords": [
        "errors"
    ],
    "author": "Naman Deep Singh",
    "license": "ISC",
    "packageManager": "pnpm@10.20.0",
    "devDependencies": {
        "@types/express": "^5.0.5",
        "@types/node": "^25.0.1",
        "express": "^5.1.0",
        "rimraf": "^5.0.5",
        "typescript": "^5.9.3"
    },
    "dependencies": {
        "@naman_deep_singh/http-response": "^3.3.1"
    },
    "publishConfig": {
        "access": "public"
    }
}
===== ./tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": [
    "src"
  ],
  "exclude": [
    "dist",
    "node_modules"
  ]
}
===== ./output.txt =====

===== ./README.md =====
```bash
@naman_deep_singh/errors

Version: 2.3.0

A standardized, code-driven error handling system for TypeScript and Express applications, providing consistent error identity, responses, and middleware integration.

üöÄ Features

‚úÖ Structured Error Classes ‚Äî AppError, HTTPError, ValidationError, etc.
‚úÖ Strongly-Typed Error Codes ‚Äî Centralized error identity via constants
‚úÖ Centralized Error Messages ‚Äî One source of truth for user-facing messages
‚úÖ Express Middleware ‚Äî Error converter & global handler
‚úÖ Response Integration ‚Äî Works seamlessly with @naman_deep_singh/http-response
‚úÖ TypeScript First ‚Äî Full type safety & IntelliSense
‚úÖ Consistent API Responses ‚Äî Unified error shape across services
‚úÖ Extendable Error Messages ‚Äî Add or override messages at runtime

üì¶ Installation
npm install @naman_deep_singh/errors

üß† Design Philosophy

This package is code-driven, not message-driven.

Errors are identified by stable error codes.

Messages are resolved internally via centralized mappings.

API contracts remain stable even if messages change.

Benefits:

‚úÖ Consistency across microservices
‚úÖ Safe refactoring
‚úÖ Better logging, tracing, and observability

üîß Usage
Creating Errors (Recommended)
import {
  BadRequestError,
  UnauthorizedError,
  NotFoundError,
  ValidationError,
  InternalServerError,
} from '@naman_deep_singh/errors'

// Basic usage
throw new BadRequestError()

throw new UnauthorizedError()

throw new NotFoundError()

// With additional details
throw new ValidationError({
  fields: ['email', 'password'],
})

throw new InternalServerError()

üßæ Error Codes & Messages
import {
  ERROR_CODES,
  ERROR_MESSAGES,
  ErrorCode,
} from '@naman_deep_singh/errors'


ERROR_CODES ‚Äî Canonical list of all supported error codes

ERROR_MESSAGES ‚Äî Mapping of error codes ‚Üí user-facing messages

ErrorCode ‚Äî Union type of all valid error codes

Why Error Codes?

‚úÖ Consistent error identity across services
‚úÖ Centralized message management
‚úÖ Safer API contracts
‚úÖ Improved logging & observability

üåê Express Middleware
import express from 'express'
import {
  errorConverter,
  expressErrorHandler,
  ValidationError,
} from '@naman_deep_singh/errors'

const app = express()

// Convert unknown / third-party errors ‚Üí AppError
app.use(errorConverter)

// Handle all errors consistently
app.use(expressErrorHandler)

app.post('/users', (req, res) => {
  if (!req.body.email) {
    throw new ValidationError({
      fields: ['email'],
    })
  }
})


Middleware Responsibilities

errorConverter ‚Äî Converts unknown errors into AppError, preserves operational errors

expressErrorHandler ‚Äî Sends standardized API responses and integrates with @naman_deep_singh/http-response

üîó Integration
With @naman_deep_singh/http-response
import { responderMiddleware } from '@naman_deep_singh/http-response'
import { expressErrorHandler } from '@naman_deep_singh/errors'

app.use(responderMiddleware())
app.use(expressErrorHandler)

With @naman_deep_singh/server
import { createServer } from '@naman_deep_singh/server'
import { expressErrorHandler } from '@naman_deep_singh/errors'

const server = createServer('My API', '1.0.0')
server.app.use(expressErrorHandler)

üß† Extending & Adding Error Messages

You can safely extend existing errors or add new codes/messages dynamically.

Extending Existing Error Class
import { InternalServerError, ERROR_CODES } from '@naman_deep_singh/errors'

export class CryptoIntegrityError extends InternalServerError {
  constructor(details?: unknown, cause?: Error) {
    super(ERROR_CODES.CRYPTO_INTEGRITY_ERROR, details, cause)
  }
}

Registering Custom Error Messages
import { errorMessageRegistry } from '@naman_deep_singh/errors'

// Add new messages or override existing ones
errorMessageRegistry.register({
  CUSTOM_ERROR: 'Something went wrong with custom logic',
  VALIDATION_FAILED: 'Custom validation failed message',
})


After this, AppError or any derived class will use the updated messages automatically.

import { AppError, ErrorCode } from '@naman_deep_singh/errors'

throw new AppError(
  'CUSTOM_ERROR' as ErrorCode,
  500,
  {
    reason: "Something went wrong with custom logic"
  }
)

üìö Available Error Classes
Class	Status Code	Use Case
AppError	Custom	Base error class
HTTPError	4xx / 5xx	Base HTTP error
BadRequestError	400	Invalid input
UnauthorizedError	401	Authentication failures
TokenExpiredError	401	Expired tokens
TokenMalformedError	401	Invalid token format
ForbiddenError	403	Authorization failures
NotFoundError	404	Resource not found
ConflictError	409	Resource conflicts
ValidationError	422	Validation errors
RateLimitError	429	Rate limiting
CryptoIntegrityError	500	Crypto validation failure
InternalServerError	500	Server-side failures
ServiceUnavailableError 500 Service not available

üéØ Standard Error Response

All errors resolve to a consistent response shape:

{
  "success": false,
  "code": "VALIDATION_FAILED",
  "message": "Validation failed",
  "details": {
    "fields": ["email"]
  },
}

üìÑ License

ISC ¬© Naman Deep Singh
```
===== ./tsconfig.types.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": false,
    "declaration": true,
    "emitDeclarationOnly": true,
    "outDir": "dist/types"
  },
  "include": [
    "src"
  ]
}
===== ./src/index.ts =====
// error registry
export * from './errorRegistry/index.js'
// default errors
export * from './error/index.js'
// Constants
export * from './constants/index.js'
// Express Middleware
export * from './middleware/express/index.js'

===== ./src/middleware/index.ts =====
export { expressErrorHandler, errorConverter } from './express/index.js'

===== ./src/middleware/express/index.ts =====
export { expressErrorHandler } from './errorHandler.middleware.js'
export { errorConverter } from './errorConverter.middleware.js'

===== ./src/middleware/express/errorHandler.middleware.ts =====
import { ExpressResponder, HTTP_STATUS } from '@naman_deep_singh/http-response'
import type { NextFunction, Request, Response } from 'express'
import { ERROR_CODES } from '../../constants/errorCodes.js'
import { AppError } from '../../error/AppError.js'
import { errorMessageRegistry } from '../../errorRegistry/index.js'

export function expressErrorHandler(
	err: unknown,
	_req: Request,
	res: Response,
	_next: NextFunction,
) {
	const responder = new ExpressResponder({}, res)

	// 1. Known operational error
	if (err instanceof AppError) {
		return errorMessageRegistry.mapAppErrorToResponder(responder, err)
	}

	// 2. Log unexpected errors (never expose internals in prod)
	console.error('UNEXPECTED ERROR:', err)

	// 3. Normalize unknown error ‚Üí AppError
	const internalError = new AppError(
		ERROR_CODES.INTERNAL_SERVER_ERROR,
		HTTP_STATUS.SERVER_ERROR.INTERNAL_SERVER_ERROR,
		process.env.NODE_ENV === 'production' ? undefined : err,
		err instanceof Error ? err : undefined,
	)

	return errorMessageRegistry.mapAppErrorToResponder(responder, internalError)
}

===== ./src/middleware/express/errorConverter.middleware.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import type { NextFunction, Request, Response } from 'express'
import { ERROR_CODES, type ErrorCode } from '../../constants/errorCodes.js'
import { AppError } from '../../error/AppError.js'

export function errorConverter(
	err: unknown,
	_req: Request,
	_res: Response,
	next: NextFunction,
) {
	// 1. Already a known AppError ‚Üí pass through
	if (err instanceof AppError) {
		return next(err)
	}

	let code: ErrorCode = ERROR_CODES.INTERNAL_SERVER_ERROR
	let statusCode: number = HTTP_STATUS.SERVER_ERROR.INTERNAL_SERVER_ERROR
	let details: unknown = undefined
	let cause: Error | undefined = undefined

	// 2. Handle unknown objects safely
	if (typeof err === 'object' && err !== null) {
		const e = err as Record<string, unknown>

		if (typeof e.code === 'string' && e.code in ERROR_CODES) {
			code = e.code as ErrorCode
		}

		if (typeof e.statusCode === 'number') {
			statusCode = e.statusCode
		}

		if ('details' in e) {
			details = e.details
		}

		if (err instanceof Error) {
			cause = err
		}
	}

	// 3. Handle string errors
	if (typeof err === 'string') {
		details = err
	}

	// 4. Convert to AppError
	const convertedError = new AppError(code, statusCode, details, cause)

	next(convertedError)
}

===== ./src/errorRegistry/errorRegistry.ts =====
import {
	type ExpressResponder,
	HTTP_STATUS,
} from '@naman_deep_singh/http-response'
import type { ErrorCode } from '../constants/errorCodes.js'
import { ERROR_MESSAGES } from '../constants/errorMessages.js'
import type { AppError } from '../error/AppError.js'

export class ErrorMessageRegistry {
	private static instance: ErrorMessageRegistry
	private readonly registry = new Map<ErrorCode | string, string>()

	private constructor() {
		// Initialize with default messages
		Object.entries(ERROR_MESSAGES).forEach(([code, message]) => {
			this.registry.set(code, message)
		})
	}

	/** Singleton accessor */
	public static getInstance(): ErrorMessageRegistry {
		if (!ErrorMessageRegistry.instance) {
			ErrorMessageRegistry.instance = new ErrorMessageRegistry()
		}
		return ErrorMessageRegistry.instance
	}

	/** Register or override messages */
	public register(messages: Record<string, string>): void {
		for (const [code, message] of Object.entries(messages)) {
			this.registry.set(code, message)
		}
	}

	/** Resolve a message for a given error code */
	public resolve(
		code: ErrorCode | string,
		defaultMessage = 'Unexpected error',
	): string {
		return this.registry.get(code) ?? defaultMessage
	}

	/**
	 * Map an AppError to an ExpressResponder
	 * Centralizes error-to-HTTP mapping
	 */
	public mapAppErrorToResponder(
		responder: ExpressResponder<unknown>,
		err: AppError,
	) {
		switch (err.statusCode) {
			case HTTP_STATUS.CLIENT_ERROR.BAD_REQUEST:
				return responder.badRequest(this.resolve(err.code), {
					details: err.details,
				})
			case HTTP_STATUS.CLIENT_ERROR.UNAUTHORIZED:
				return responder.unauthorized(this.resolve(err.code))
			case HTTP_STATUS.CLIENT_ERROR.FORBIDDEN:
				return responder.forbidden(this.resolve(err.code))
			case HTTP_STATUS.CLIENT_ERROR.NOT_FOUND:
				return responder.notFound(this.resolve(err.code))
			case HTTP_STATUS.CLIENT_ERROR.CONFLICT:
				return responder.conflict(this.resolve(err.code))
			case HTTP_STATUS.CLIENT_ERROR.UNPROCESSABLE_ENTITY:
				return responder.unprocessableEntity(this.resolve(err.code), {
					details: err.details,
				})
			case HTTP_STATUS.CLIENT_ERROR.TOO_MANY_REQUESTS:
				return responder.tooManyRequests(this.resolve(err.code))
			default:
				// Any other status maps to generic server error
				return responder.serverError(this.resolve(err.code), {
					details: err.details,
				})
		}
	}
}

/** Singleton export for easy access */
export const errorMessageRegistry = ErrorMessageRegistry.getInstance()

===== ./src/errorRegistry/index.ts =====
export { ErrorMessageRegistry, errorMessageRegistry } from './errorRegistry.js'

===== ./src/constants/index.ts =====
export { ERROR_CODES, type ErrorCode } from './errorCodes.js'
export { ERROR_MESSAGES } from './errorMessages.js'

===== ./src/constants/errorCodes.ts =====
export const ERROR_CODES = {
	/* ------------------------------------------------------------------ */
	/* üß± Common / Generic                                                  */
	/* ------------------------------------------------------------------ */
	BAD_REQUEST: 'BAD_REQUEST',
	VALIDATION_FAILED: 'VALIDATION_FAILED',
	UNAUTHORIZED: 'UNAUTHORIZED',
	FORBIDDEN: 'FORBIDDEN',
	NOT_FOUND: 'NOT_FOUND',
	CONFLICT: 'CONFLICT',
	TOO_MANY_REQUESTS: 'TOO_MANY_REQUESTS',

	INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
	SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',
	DEPENDENCY_FAILURE: 'DEPENDENCY_FAILURE',

	/* ------------------------------------------------------------------ */
	/* üåê HTTP / Network                                                    */
	/* ------------------------------------------------------------------ */
	HTTP_ERROR: 'HTTP_ERROR',
	HTTP_TIMEOUT: 'HTTP_TIMEOUT',
	UPSTREAM_SERVICE_ERROR: 'UPSTREAM_SERVICE_ERROR',

	/* ------------------------------------------------------------------ */
	/* üîê Authentication / Authorization                                   */
	/* ------------------------------------------------------------------ */
	AUTH_FAILED: 'AUTH_FAILED',
	TOKEN_MISSING: 'TOKEN_MISSING',
	TOKEN_INVALID: 'TOKEN_INVALID',
	TOKEN_EXPIRED: 'TOKEN_EXPIRED',

	/* ------------------------------------------------------------------ */
	/* üîë Cryptography / Security                                          */
	/* ------------------------------------------------------------------ */
	CRYPTO_ERROR: 'CRYPTO_ERROR',
	CRYPTO_INTEGRITY_ERROR: 'CRYPTO_INTEGRITY_ERROR',

	/* ------------------------------------------------------------------ */
	/* üíæ Cache                                                             */
	/* ------------------------------------------------------------------ */
	CACHE_ERROR: 'CACHE_ERROR',
	CACHE_CONNECTION_FAILED: 'CACHE_CONNECTION_FAILED',

	/* ------------------------------------------------------------------ */
	/* üóÑÔ∏è Database                                                          */
	/* ------------------------------------------------------------------ */
	DATABASE_ERROR: 'DATABASE_ERROR',
	DATABASE_CONNECTION_FAILED: 'DATABASE_CONNECTION_FAILED',
	DATABASE_CONSTRAINT_VIOLATION: 'DATABASE_CONSTRAINT_VIOLATION',

	/* ------------------------------------------------------------------ */
	/* üì© Messaging / Queues                                                */
	/* ------------------------------------------------------------------ */
	MESSAGE_BROKER_ERROR: 'MESSAGE_BROKER_ERROR',
	MESSAGE_PUBLISH_FAILED: 'MESSAGE_PUBLISH_FAILED',

	/* ------------------------------------------------------------------ */
	/* üìÅ File / Storage                                                    */
	/* ------------------------------------------------------------------ */
	FILE_ERROR: 'FILE_ERROR',
	FILE_NOT_FOUND: 'FILE_NOT_FOUND',
	FILE_UPLOAD_FAILED: 'FILE_UPLOAD_FAILED',
	FILE_TOO_LARGE: 'FILE_TOO_LARGE',

	/* ------------------------------------------------------------------ */
	/* ‚öôÔ∏è Configuration / Environment                                      */
	/* ------------------------------------------------------------------ */
	CONFIG_ERROR: 'CONFIG_ERROR',
	CONFIG_MISSING: 'CONFIG_MISSING',

	/* ------------------------------------------------------------------ */
	/* ‚è±Ô∏è Timeouts / Resources                                              */
	/* ------------------------------------------------------------------ */
	TIMEOUT_ERROR: 'TIMEOUT_ERROR',
	RESOURCE_EXHAUSTED: 'RESOURCE_EXHAUSTED',
} as const

export type ErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES]

===== ./src/constants/errorMessages.ts =====
/**
 * Canonical error messages mapped to ERROR_CODES
 * - Human-readable
 * - Safe for API responses
 * - Useful for logs
 * - Can be overridden by services if needed
 */

import { ERROR_CODES, type ErrorCode } from './errorCodes.js'

export const ERROR_MESSAGES: Record<ErrorCode, string> = {
	/* ------------------------------------------------------------------ */
	/* üß± Common / Generic                                                  */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.BAD_REQUEST]: 'The request is invalid or malformed.',
	[ERROR_CODES.VALIDATION_FAILED]: 'Request validation failed.',
	[ERROR_CODES.UNAUTHORIZED]: 'Authentication is required.',
	[ERROR_CODES.FORBIDDEN]: 'You do not have permission to perform this action.',
	[ERROR_CODES.NOT_FOUND]: 'The requested resource was not found.',
	[ERROR_CODES.CONFLICT]:
		'The request could not be completed due to a conflict.',
	[ERROR_CODES.TOO_MANY_REQUESTS]: 'Too many requests. Please try again later.',

	[ERROR_CODES.INTERNAL_SERVER_ERROR]: 'An unexpected internal error occurred.',
	[ERROR_CODES.SERVICE_UNAVAILABLE]: 'The service is currently unavailable.',
	[ERROR_CODES.DEPENDENCY_FAILURE]: 'A dependent service failed to respond.',

	/* ------------------------------------------------------------------ */
	/* üåê HTTP / Network                                                    */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.HTTP_ERROR]:
		'An HTTP error occurred while processing the request.',
	[ERROR_CODES.HTTP_TIMEOUT]: 'The request timed out.',
	[ERROR_CODES.UPSTREAM_SERVICE_ERROR]:
		'An upstream service returned an error.',

	/* ------------------------------------------------------------------ */
	/* üîê Authentication / Authorization                                   */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.AUTH_FAILED]: 'Authentication failed.',
	[ERROR_CODES.TOKEN_MISSING]: 'Authentication token is missing.',
	[ERROR_CODES.TOKEN_INVALID]: 'Authentication token is invalid.',
	[ERROR_CODES.TOKEN_EXPIRED]: 'Authentication token has expired.',

	/* ------------------------------------------------------------------ */
	/* üîë Cryptography / Security                                          */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.CRYPTO_ERROR]: 'A cryptographic operation failed.',
	[ERROR_CODES.CRYPTO_INTEGRITY_ERROR]: 'Data integrity verification failed.',

	/* ------------------------------------------------------------------ */
	/* üíæ Cache                                                             */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.CACHE_ERROR]: 'A cache operation failed.',
	[ERROR_CODES.CACHE_CONNECTION_FAILED]:
		'Failed to connect to the cache store.',

	/* ------------------------------------------------------------------ */
	/* üóÑÔ∏è Database                                                          */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.DATABASE_ERROR]: 'A database error occurred.',
	[ERROR_CODES.DATABASE_CONNECTION_FAILED]:
		'Failed to connect to the database.',
	[ERROR_CODES.DATABASE_CONSTRAINT_VIOLATION]:
		'The operation violates a database constraint.',

	/* ------------------------------------------------------------------ */
	/* üì© Messaging / Queues                                                */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.MESSAGE_BROKER_ERROR]: 'A message broker error occurred.',
	[ERROR_CODES.MESSAGE_PUBLISH_FAILED]:
		'Failed to publish message to the message broker.',

	/* ------------------------------------------------------------------ */
	/* üìÅ File / Storage                                                    */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.FILE_ERROR]: 'A file operation failed.',
	[ERROR_CODES.FILE_NOT_FOUND]: 'The requested file was not found.',
	[ERROR_CODES.FILE_UPLOAD_FAILED]: 'File upload failed.',
	[ERROR_CODES.FILE_TOO_LARGE]: 'The uploaded file exceeds the allowed size.',

	/* ------------------------------------------------------------------ */
	/* ‚öôÔ∏è Configuration / Environment                                      */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.CONFIG_ERROR]: 'Configuration error detected.',
	[ERROR_CODES.CONFIG_MISSING]: 'Required configuration is missing.',

	/* ------------------------------------------------------------------ */
	/* ‚è±Ô∏è Timeouts / Resources                                              */
	/* ------------------------------------------------------------------ */
	[ERROR_CODES.TIMEOUT_ERROR]: 'The operation timed out.',
	[ERROR_CODES.RESOURCE_EXHAUSTED]:
		'The system has exhausted required resources.',
}

===== ./src/error/index.ts =====
export { AppError } from './AppError.js'
export { HTTPError } from './HTTPError.js'

// =========================
// 4xx Client Errors
// =========================
export { BadRequestError } from './BadRequestError.js'
export { UnauthorizedError } from './UnauthorizedError.js'
export { ForbiddenError } from './ForbiddenError.js'
export { NotFoundError } from './NotFoundError.js'
export { ConflictError } from './ConflictError.js'
export { ValidationError } from './ValidationError.js'
export { TooManyRequestsError } from './TooManyRequestsError.js'

// =========================
// Auth / Token Errors
// =========================
export { TokenExpiredError } from './TokenExpiredError.js'
export { TokenMalformedError } from './TokenMalformedError.js'

// =========================
// 5xx Server Errors
// =========================
export { InternalServerError } from './InternalServerError.js'
export { CryptoIntegrityError } from './CryptoIntegrityError.js'
export { ServiceUnavailableError } from './ServiceUnavailableError.js'

===== ./src/error/NotFoundError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class NotFoundError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.NOT_FOUND,
			HTTP_STATUS.CLIENT_ERROR.NOT_FOUND,
			details,
			cause,
		)
	}
}

===== ./src/error/ConflictError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class ConflictError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.CONFLICT,
			HTTP_STATUS.CLIENT_ERROR.CONFLICT,
			details,
			cause,
		)
	}
}

===== ./src/error/TokenMalformedError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class TokenMalformedError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.TOKEN_INVALID,
			HTTP_STATUS.CLIENT_ERROR.UNAUTHORIZED,
			details,
			cause,
		)
	}
}

===== ./src/error/UnauthorizedError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class UnauthorizedError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.UNAUTHORIZED,
			HTTP_STATUS.CLIENT_ERROR.UNAUTHORIZED,
			details,
			cause,
		)
	}
}

===== ./src/error/InternalServerError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES, type ErrorCode } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class InternalServerError extends HTTPError {
	constructor(
		errorCode: ErrorCode = ERROR_CODES.INTERNAL_SERVER_ERROR,
		details?: unknown,
		cause?: Error,
	) {
		super(
			errorCode,
			HTTP_STATUS.SERVER_ERROR.INTERNAL_SERVER_ERROR,
			details,
			cause,
		)
	}
}

===== ./src/error/ForbiddenError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class ForbiddenError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.FORBIDDEN,
			HTTP_STATUS.CLIENT_ERROR.FORBIDDEN,
			details,
			cause,
		)
	}
}

===== ./src/error/TokenExpiredError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class TokenExpiredError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.TOKEN_EXPIRED,
			HTTP_STATUS.CLIENT_ERROR.UNAUTHORIZED,
			details,
			cause,
		)
	}
}

===== ./src/error/CryptoIntegrityError.ts =====
import { ERROR_CODES } from '../constants/errorCodes.js'
import { InternalServerError } from './InternalServerError.js'

export class CryptoIntegrityError extends InternalServerError {
	constructor(details?: unknown, cause?: Error) {
		super(ERROR_CODES.CRYPTO_INTEGRITY_ERROR, details, cause)
	}
}

===== ./src/error/TooManyRequestsError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES, type ErrorCode } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class TooManyRequestsError extends HTTPError {
	constructor(
		errorCode: ErrorCode = ERROR_CODES.TOO_MANY_REQUESTS,
		details?: unknown,
		cause?: Error,
	) {
		super(errorCode, HTTP_STATUS.CLIENT_ERROR.TOO_MANY_REQUESTS, details, cause)
	}
}

===== ./src/error/ServiceUnavailableError.ts =====
import { ERROR_CODES } from '../constants/errorCodes.js'
import { InternalServerError } from './InternalServerError.js'

export class ServiceUnavailableError extends InternalServerError {
	constructor(details?: unknown, cause?: Error) {
		super(ERROR_CODES.SERVICE_UNAVAILABLE, details, cause)
	}
}

===== ./src/error/BadRequestError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class BadRequestError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.BAD_REQUEST,
			HTTP_STATUS.CLIENT_ERROR.BAD_REQUEST,
			details,
			cause,
		)
	}
}

===== ./src/error/HTTPError.ts =====
import type { ErrorCode } from '../constants/errorCodes.js'
import { AppError } from './AppError.js'

export class HTTPError extends AppError {
	public status: 'fail' | 'error'

	constructor(
		errorCode: ErrorCode,
		statusCode: number,
		details?: unknown,
		cause?: Error,
	) {
		super(errorCode, statusCode, details, cause)

		this.status = statusCode >= 400 && statusCode < 500 ? 'fail' : 'error'
	}
}

===== ./src/error/AppError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import type { ErrorCode } from '../constants/errorCodes.js'
import { errorMessageRegistry } from '../errorRegistry/errorRegistry.js'

export class AppError extends Error {
	public statusCode: number
	public isOperational: boolean
	public code: ErrorCode
	public details?: unknown
	public cause?: Error

	constructor(
		code: ErrorCode,
		statusCode: number = HTTP_STATUS.SERVER_ERROR.INTERNAL_SERVER_ERROR,
		details?: unknown,
		cause?: Error,
	) {
		super(errorMessageRegistry.resolve(code)) // message comes from mapping
		this.code = code
		this.statusCode = statusCode
		this.isOperational = true
		this.details = details

		if (cause) this.cause = cause
		Error.captureStackTrace(this, this.constructor)
	}

	toJSON() {
		return {
			success: false,
			code: this.code,
			message: this.message,
			details: this.details ?? null,
		}
	}
}

===== ./src/error/ValidationError.ts =====
import { HTTP_STATUS } from '@naman_deep_singh/http-response'
import { ERROR_CODES } from '../constants/errorCodes.js'
import { HTTPError } from './HTTPError.js'

export class ValidationError extends HTTPError {
	constructor(details?: unknown, cause?: Error) {
		super(
			ERROR_CODES.VALIDATION_FAILED,
			HTTP_STATUS.CLIENT_ERROR.UNPROCESSABLE_ENTITY,
			details,
			cause,
		)
	}
}

===== ./tsconfig.cjs.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "strict": true,
    "esModuleInterop": true,
    "outDir": "dist/cjs"
  },
  "include": [
    "src"
  ]
}
===== ./tsconfig.esm.json =====
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "outDir": "dist/esm"
  },
  "include": [
    "src"
  ]
}